<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="apple-touch-icon" href="icon.png">
    <title>Sleepy Bobby</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bobby">
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --primary: #38bdf8;
            --bird-grey: #b8b0a5; --bird-dark-grey: #8d7e71; --bird-orange: #e65a28; --branch-brown: #8b5d43;
        }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; position: fixed; background: var(--bg); font-family: system-ui, sans-serif; color: var(--text); }
        body { display: flex; align-items: center; justify-content: center; }

        .anim-container { position: absolute; top: 0; left: 0; width: 100%; height: 60%; z-index: 0; overflow: hidden; pointer-events: none; }
        
        /* PLUIE - Image Base64 pour éviter une requête HTTP */
        .rain { position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='); opacity: 0; transition: opacity 1s; }
        .rain.active { opacity: 0.1; animation: rainAnim 0.5s linear infinite; }
        @keyframes rainAnim { 0% { background-position: 0 0; } 100% { background-position: 20px 100px; } }

        .container { z-index: 10; text-align: center; width: 90%; max-width: 350px; display: flex; flex-direction: column; gap: 20px; }
        
        .card { background: var(--card); padding: 20px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 15px; transition: transform 0.2s; }
        select, button { width: 100%; padding: 12px; border-radius: 10px; border: none; font-size: 16px; outline: none; background: #334155; color: white; -webkit-appearance: none; text-align: center; }
        button { background: var(--primary); color: #0f172a; font-weight: bold; cursor: pointer; transition: transform 0.1s, background 0.2s; }
        button:active { transform: scale(0.96); }
        button.stop { background: #ef4444; color: white; }

        input[type=range] { width: 100%; accent-color: var(--primary); height: 6px; border-radius: 3px; background: #334155; }

        /* OISEAU (Bobby) - Design original conservé */
        .scene { width: 200px; height: 160px; margin: 0 auto; position: relative; }
        .branch { position: absolute; bottom: 30px; left: 10px; width: 180px; height: 8px; background: var(--branch-brown); border-radius: 4px; transform: rotate(-5deg); }
        .bird { position: absolute; bottom: 36px; left: 60px; width: 80px; height: 70px; background: var(--bird-grey); border-radius: 50% 50% 40% 40%; box-shadow: inset -5px -5px 0 rgba(0,0,0,0.1); transition: transform 0.5s; }
        .is-sleeping .bird { animation: breathe 4s ease-in-out infinite; }
        @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03) translateY(-1px); } }
        
        .belly { position: absolute; bottom: 0; left: 15%; width: 70%; height: 45%; background: white; opacity: 0.8; border-radius: 50% 50% 40% 40%; }
        .face { position: absolute; top: 15px; left: 15px; width: 50px; height: 30px; }
        .eye { position: absolute; top: 8px; width: 10px; height: 10px; background: #000; border-radius: 50%; transition: all 0.3s; }
        .eye.left { left: 5px; } .eye.right { right: 5px; }
        
        /* Paupières */
        .eyelid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--bird-grey); top: -100%; transition: top 0.3s; }
        .is-sleeping .eye { height: 2px; top: 12px; border-radius: 0; }
        
        .beak { position: absolute; top: 18px; left: 20px; width: 12px; height: 8px; background: var(--bird-orange); border-radius: 50%; transform: rotate(10deg); }
        .zzz { position: absolute; top: -20px; right: -20px; font-size: 20px; color: var(--text); opacity: 0; font-weight: bold; }
        .is-sleeping .zzz { animation: zzzAnim 3s infinite; }
        @keyframes zzzAnim { 0% { opacity: 0; transform: translateY(0) scale(0.8); } 50% { opacity: 1; } 100% { opacity: 0; transform: translateY(-30px) scale(1.2); } }

        .status-text { font-size: 0.9em; opacity: 0.7; margin-top: 5px; height: 20px; }
    </style>
</head>
<body>

    <div class="anim-container">
        <div class="rain" id="rainLayer"></div>
    </div>

    <div class="container">
        <div class="scene" id="bobby">
            <div class="zzz">Zzz</div>
            <div class="bird">
                <div class="belly"></div>
                <div class="face">
                    <div class="eye left"></div>
                    <div class="eye right"></div>
                    <div class="beak"></div>
                </div>
            </div>
            <div class="branch"></div>
        </div>

        <div class="card">
            <select id="modeSelect">
                <option value="rain">Pluie Légère</option>
                <option value="storm">Orage Lointain</option>
                <option value="wind">Vent dans les arbres</option>
                <option value="river">Rivière</option>
                <option value="waves">Vagues (Océan)</option>
                <option value="fire">Feu de camp</option>
                <option value="pink">Bruit Rose (Focus)</option>
                <option value="space">Espace (Deep Drone)</option>
            </select>

            <div style="display:flex; justify-content: space-between; font-size: 0.8em; opacity: 0.8;">
                <span>Volume</span>
                <span id="volPerc">50%</span>
            </div>
            <input type="range" id="volume" min="0" max="1" step="0.01" value="0.5">

            <select id="timerSelect">
                <option value="0">Minuteur: Off</option>
                <option value="15">15 Minutes</option>
                <option value="30">30 Minutes</option>
                <option value="60">1 Heure</option>
                <option value="120">2 Heures</option>
            </select>

            <button id="playBtn">DORMIR</button>
        </div>
        <div class="status-text" id="phraseDay">Bobby attend...</div>
    </div>

<script>
    // --- VARIABLES GLOBALES ---
    let isPlaying = false;
    let audioCtx;
    let masterGain;
    let currentSource = null; // Stocke l'objet source actif
    
    // Cache pour les buffers (évite de recalculer les bruits = économie batterie)
    const bufferCache = { white: null, pink: null, brown: null, click: null };

    // Timer
    let countdownInterval;
    let timeLeft = 0;

    // Phrases
    const phrases = [
        "Chut... Bobby s'endort.", "Fais de beaux rêves.", "Respire calmement...", 
        "La nuit est douce.", "Lâche prise...", "Tout est calme."
    ];

    // --- MOTEUR AUDIO OPTIMISÉ ---
    
    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            
            // Génération UNIQUE des bruits au démarrage
            if(!bufferCache.white) bufferCache.white = createNoiseBuffer('white');
            if(!bufferCache.pink) bufferCache.pink = createNoiseBuffer('pink');
            if(!bufferCache.brown) bufferCache.brown = createNoiseBuffer('brown');
            if(!bufferCache.click) bufferCache.click = createClickBuffer();
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();
    }

    // Créateur de Bruit (Factory)
    function createNoiseBuffer(type) {
        const bufferSize = 2 * audioCtx.sampleRate; // 2 secondes de boucle suffisent
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = buffer.getChannelData(0);
        let lastOut = 0;
        let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;

        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            if (type === 'white') { output[i] = white; } 
            else if (type === 'brown') {
                output[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = output[i];
                output[i] *= 3.5; 
            } 
            else if (type === 'pink') {
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                b6 = white * 0.115926;
            }
        }
        return buffer;
    }

    // Petit buffer pour gouttes et craquements (évite créations répétées)
    function createClickBuffer() {
        const buf = audioCtx.createBuffer(1, 0.02 * audioCtx.sampleRate, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0; i<d.length; i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(audioCtx.sampleRate*0.002));
        return buf;
    }

    function playLoop(type) {
        const src = audioCtx.createBufferSource();
        src.buffer = bufferCache[type];
        src.loop = true;
        return src;
    }

    // --- LOGIQUE PRINCIPALE ---

    async function startBobby() {
        const btn = document.getElementById('playBtn');
        const mode = document.getElementById('modeSelect').value;
        const bobby = document.getElementById('bobby');

        await initAudio();

        if (isPlaying) {
            stopAudio(true); 
            setTimeout(() => launchMode(mode), 350);
        } else {
            launchMode(mode);
        }
        
        isPlaying = true;
        bobby.classList.add('is-sleeping');
        btn.textContent = "ARRÊTER";
        btn.classList.add('stop');
        
        handleTimer();
        toggleAnimation('rain', mode === 'rain' || mode === 'storm');
    }

    function launchMode(mode) {
        updateVolume(document.getElementById('volume').value);
        switch (mode) {
            case 'rain': createRain(false); break;
            case 'storm': createRain(true); break;
            case 'wind': createWind(); break;
            case 'fire': createFire(); break;
            case 'river': createRiver(); break;
            case 'waves': createWaves(); break;
            case 'pink': createSimpleNoise('pink'); break;
            case 'space': createSpace(); break;
        }
    }

    function stopBobby() {
        stopAudio(true); // Fade out doux
        isPlaying = false;
        
        const bobby = document.getElementById('bobby');
        bobby.classList.remove('is-sleeping');
        
        const btn = document.getElementById('playBtn');
        btn.textContent = "DORMIR";
        btn.classList.remove('stop');
        
        clearInterval(countdownInterval);
        resetTimerUI();
        toggleAnimation('rain', false);
        document.getElementById('phraseDay').textContent = "Bobby est réveillé.";
    }

    function stopAudio(fade = false) {
        if (!currentSource) return;
        const srcToStop = currentSource;
        currentSource = null;

        try {
            if (fade && masterGain) {
                const now = audioCtx.currentTime;
                masterGain.gain.cancelScheduledValues(now);
                masterGain.gain.setValueAtTime(masterGain.gain.value, now);
                masterGain.gain.linearRampToValueAtTime(0, now + 0.5);
                setTimeout(() => { if (srcToStop.stop) srcToStop.stop(); }, 550);
            } else {
                if (srcToStop.stop) srcToStop.stop();
            }
        } catch(e) { console.error(e); }
    }

    function updateVolume(val) {
        if (masterGain && audioCtx) {
            masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
            masterGain.gain.setValueAtTime(parseFloat(val), audioCtx.currentTime);
        }
    }

    // --- GENERATEURS DE SON (OPTIMISÉS) ---

    function createSimpleNoise(type) {
        const src = playLoop(type);
        src.connect(masterGain);
        src.start();
        currentSource = { stop: () => { src.stop(); src.disconnect(); } };
    }

    function createWind() {
        const src = playLoop('white');
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 400;
        const gain = audioCtx.createGain();
        src.connect(filter).connect(gain).connect(masterGain);
        src.start();

        let timer;
        const loop = () => {
            if (!isPlaying) return;
            const now = audioCtx.currentTime;
            const dur = 2 + Math.random() * 4;
            filter.frequency.exponentialRampToValueAtTime(600 + Math.random()*400, now + dur/2);
            filter.frequency.exponentialRampToValueAtTime(300, now + dur);
            timer = setTimeout(loop, dur * 1000);
        };
        loop();
        currentSource = { stop: () => { clearTimeout(timer); src.stop(); src.disconnect(); filter.disconnect(); gain.disconnect(); } };
    }

    function createRiver() {
        const src = playLoop('brown');
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 600;
        const panner = audioCtx.createStereoPanner();
        panner.pan.value = 0.1;
        src.connect(filter).connect(panner).connect(masterGain);
        src.start();
        currentSource = { stop: () => { src.stop(); src.disconnect(); filter.disconnect(); } };
    }

    function createSpace() {
        const src = playLoop('brown');
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 150; filter.Q.value = 2;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine'; osc.frequency.value = 50;
        const oscGain = audioCtx.createGain(); oscGain.gain.value = 0.1;
        src.connect(filter).connect(masterGain);
        osc.connect(oscGain).connect(masterGain);
        src.start(); osc.start();
        currentSource = { stop: () => { src.stop(); osc.stop(); src.disconnect(); filter.disconnect(); osc.disconnect(); } };
    }

    function createFire() {
        const rumble = playLoop('brown');
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 500;
        const fireGain = audioCtx.createGain(); fireGain.gain.value = 0.8;
        rumble.connect(filter).connect(fireGain).connect(masterGain);
        rumble.start();

        let timer;
        const crackle = () => {
            if (!isPlaying) return;
            const src = audioCtx.createBufferSource();
            src.buffer = bufferCache.click;
            const g = audioCtx.createGain(); g.gain.value = 0.5 + Math.random() * 0.5;
            const f = audioCtx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 1000;
            src.connect(f).connect(g).connect(masterGain);
            src.start();
            timer = setTimeout(crackle, 50 + Math.random() * 150);
        };
        crackle();
        currentSource = { stop: () => { clearTimeout(timer); rumble.stop(); rumble.disconnect(); filter.disconnect(); } };
    }

    function createWaves() {
        const src = playLoop('pink');
        const waveGain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 500;
        src.connect(filter).connect(waveGain).connect(masterGain);
        src.start();

        let timer;
        const roll = () => {
            if (!isPlaying) return;
            const now = audioCtx.currentTime;
            const dur = 4 + Math.random() * 4;
            waveGain.gain.exponentialRampToValueAtTime(0.8, now + dur/2);
            waveGain.gain.exponentialRampToValueAtTime(0.2, now + dur);
            filter.frequency.linearRampToValueAtTime(900, now + dur/2);
            filter.frequency.linearRampToValueAtTime(400, now + dur);
            timer = setTimeout(roll, dur * 1000);
        };
        roll();
        currentSource = { stop: () => { clearTimeout(timer); src.stop(); src.disconnect(); waveGain.disconnect(); } };
    }

    function createRain(isStorm) {
        const bgNoise = playLoop('pink');
        const bgFilter = audioCtx.createBiquadFilter();
        bgFilter.type = 'lowpass'; bgFilter.frequency.value = 800;
        const bgGain = audioCtx.createGain(); bgGain.gain.value = 0.4;
        bgNoise.connect(bgFilter).connect(bgGain).connect(masterGain);
        bgNoise.start();

        let dropTimer, thunderTimer;
        const dropLoop = () => {
            if (!isPlaying) return;
            const src = audioCtx.createBufferSource();
            src.buffer = bufferCache.click;
            const g = audioCtx.createGain(); g.gain.value = 0.1 + Math.random() * 0.2;
            src.connect(g).connect(masterGain);
            src.start();
            dropTimer = setTimeout(dropLoop, 20 + Math.random()*50);
        };
        dropLoop();

        if (isStorm) {
            const thunderLoop = () => {
                if (!isPlaying) return;
                triggerThunder();
                thunderTimer = setTimeout(thunderLoop, 5000 + Math.random() * 15000);
            };
            setTimeout(thunderLoop, 2000);
        }
        currentSource = { stop: () => { clearTimeout(dropTimer); clearTimeout(thunderTimer); bgNoise.stop(); bgNoise.disconnect(); } };
    }

    function triggerThunder() {
        const dur = 1.5;
        const src = playLoop('brown');
        const g = audioCtx.createGain();
        const f = audioCtx.createBiquadFilter();
        f.type = 'lowpass'; f.frequency.value = 200;
        src.connect(f).connect(g).connect(masterGain);
        const now = audioCtx.currentTime;
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(1, now + 0.1);
        g.gain.exponentialRampToValueAtTime(0.01, now + dur);
        src.start();
        src.stop(now + dur + 0.5);
    }

    // --- ANIMATION & HELPERS ---

    function toggleAnimation(type, isActive) {
        if (type === 'rain') {
            const el = document.getElementById('rainLayer');
            if(isActive) el.classList.add('active'); else el.classList.remove('active');
        }
    }

    function displayNewPhrase() {
        const r = Math.floor(Math.random() * phrases.length);
        document.getElementById('phraseDay').textContent = phrases[r];
    }

    function handleTimer() {
        clearInterval(countdownInterval);
        resetTimerUI(); 

        const s = document.getElementById('timerSelect');
        const selectedOption = s.options[s.selectedIndex]; 
        const originalText = selectedOption.text;
        let mins = parseInt(s.value);

        if (mins > 0) {
            timeLeft = mins * 60;
            countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) { stopBobby(); } 
                else {
                    let m = Math.floor(timeLeft / 60);
                    let sec = timeLeft % 60;
                    selectedOption.text = `${m}:${sec < 10 ? '0' : ''}${sec}`;
                }
            }, 1000);
            s.dataset.originalText = originalText; 
        }
    }

    function resetTimerUI() {
        const s = document.getElementById('timerSelect');
        s.options[1].text = "15 Minutes";
        s.options[2].text = "30 Minutes";
        s.options[3].text = "1 Heure";
        s.options[4].text = "2 Heures";
    }

    document.getElementById('timerSelect').addEventListener('change', () => { if (isPlaying) startBobby(); });
    document.getElementById('playBtn').addEventListener('click', () => isPlaying ? stopBobby() : startBobby());
    document.getElementById('modeSelect').addEventListener('change', () => isPlaying && startBobby());
    
    document.getElementById('volume').addEventListener('input', (e) => {
        document.getElementById('volPerc').textContent = Math.round(e.target.value * 100) + "%";
        updateVolume(e.target.value);
    });

    displayNewPhrase();

    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(() => { });
    }
</script>
</body>
</html>
